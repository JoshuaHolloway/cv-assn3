#include "header.h"
#include "Matlab_Class.h"
#include <numeric>
//===================================================================
void part_2()
{
	/// Part 1:
	// 2D points (data from: rubik_2D_pts.mat)
	const double pts_2d[2][N] =
	{
		{ 553.174856674857,	742.291973791974,	936.021703521704,	1128.07411957412,	561.980753480754,	749.839885339885,	938.537674037674,	1121.36486486487,	573.721949221949,	754.871826371827,	941.053644553645,	1121.78419328419,	582.947174447175,	759.065110565111,	942.311629811630,	1121.78419328419,	562.819410319410,	744.807944307945,	931.828419328420,	1115.91359541360,	576.657248157248,	750.259213759214,	928.893120393121,	1103.75307125307,	587.559787059787,	754.452497952498,	926.377149877150,	1095.36650286650 },
	{ 583.156838656839,	586.930794430794,	593.640049140049,	598.671990171990,	429.682637182637,	430.521294021294,	432.198607698608,	436.391891891892,	270.337837837838,	273.692465192465,	276.627764127764, 279.143734643735,	126.927518427519,	127.346846846847,	131.540131040131,	133.636773136773,	680.441031941032,	681.699017199017,	685.472972972973,	688.827600327601,	766.403357903358,	767.242014742015,	769.757985257986,	773.531941031941,	843.140458640459,	841.463144963145,	843.979115479116,	850.269041769042 }
	};

	// 3D points (data from: rubik_3D_pts.mat)
	const double pts_3d[3][N] =
	{
		{ 0,	1,	2,	3,	0,	1,	2,	3,	0,	1,	2,	3,	0,	1,	2,	3,	0,	1,	2,	3,	0,	1,	2,	3,	0,	1,	2,	3 },
	{ 0,	0,	0,	0,	1,	1,	1,	1,	2,	2,	2,	2,	3,	3,	3,	3,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0 },
	{ 0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0, -1, -1, -1, -1, -2, -2, -2, -2, -3, -3, -3, -3 }
	};

	// Non-homogeneous coordinates
	Mat x = copy_2_mat(pts_2d); // 2D-points in image plane
	Mat X = copy_2_mat(pts_3d); // 3D-world points world

	// Homo-geneous coordinates
	Mat x_ = to_homo(x);
	Mat X_ = to_homo(X);
	
	// Estimate projection matrix P
	Mat P = calibrate(x_, X_);

	// Re-project the 3D-world points into the 2D-image plane
	auto x_reproject_ = P * X_;
	//cout << "x_1_reproject" << x_1_reproject_;

	// Map from homo to non-homo coordinates:
	auto x_reproject = from_homo(x_reproject_);
	//cout << "x_reproject" << x_reproject;

	/// Compute re-projection error

	// Get into form that matches notation from LM-implementation notes:
	vector<double> x_u, x_v;      // row-vec
	vector<double> x_u_hat, x_v_hat;  // row-vec
	for (int j = 0; j < N; ++j) // itterate across cols
	{
		x_u.push_back(x.at<double>(0, j));
		x_v.push_back(x.at<double>(1, j));

		x_u_hat.push_back(x_reproject.at<double>(0, j));
		x_v_hat.push_back(x_reproject.at<double>(1, j));
	}

	// Form d-vector
	vector<double> d;
	double l2 = 0;
	for (int j = 0; j < N; ++j)
	{
		auto d_jx = x_u[j] - x_u_hat[j];
		auto d_jy = x_v[j] - x_v_hat[j];

		d.push_back(d_jx);
		d.push_back(d_jy);

		l2 += d_jx * d_jx + d_jy * d_jy;
	}
	l2 = sqrt(l2) / static_cast<double>(N);

	// Perform inner product with self
	auto l2_v2 = sqrt(std::inner_product(d.begin(), d.end(), d.begin(), 0)) / static_cast<double>(N);
	cout << "\nl2-norm with stl (something is wrong though) = " << l2_v2 << "\n";
	cout << "l2 error manual (correct) = " << l2 << "\n";

	// Look at image
	auto img = imread("rubik_cube.jpg", CV_LOAD_IMAGE_GRAYSCALE);
	Mat img_c;
	//Mat img_c2;
	cvtColor(img, img_c, cv::COLOR_GRAY2BGR);
	//cvtColor(img, img_c2, cv::COLOR_GRAY2BGR);

	// Draw points on image
	Scalar color;
	draw_points(img_c, x_u, x_v, color = Scalar(255, 0, 255));
	draw_points(img_c, x_u_hat, x_v_hat, color = Scalar(0, 2550, 0));

	/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	/// Decompose the projection matrix into P = K * [R t]
	/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	Proj_struct proj(P);
	proj.P_to_KRt();

	cout << "\n in main function \n\n\n";
	cout << "\n\nK:\n" << proj.K;
	cout << "\n\nR:\n" << proj.R;
	cout << "\n\nt:\n" << proj.t;

	/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	/// Protoyping stuff:
	/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	// Link to MATLAB environment
	matlabClass matlab;
	matlab.passImageIntoMatlab(x_reproject);
	//matlab.passImageIntoMatlab(A);

	// Run MATLAB script that executes prototype
	matlab.command("ass3");

	imshow("test", img_c);
	waitKey(0);
}
//===============================================================
void part_1()
{
	const double pts_3d[3][N] =
	{
		{-1.57503155392540, -0.575298764228468,	0.424434025468468,	1.42416681516541, -1.55191826257183, -0.552185472874895,	0.447547316822041,	1.44728010651898, -1.52880497121826, -0.529072181521322,	0.470660608175614,	1.47039339787255, -1.50569167986469, -0.505958890167749,	0.493773899529187,	1.49350668922612, -1.57538506147297, -0.575652271776032,	0.424080517920904,	1.42381330761784, -1.57573856902053, -0.576005779323596,	0.423727010373340,	1.42345980007028, -1.57609207656810, -0.576359286871160,	0.423373502825777,	1.42310629252271},
		{-0.203996391907591, -0.183669572186910, -0.163342752466229, -0.143015932745548, -1.07571633514566, -1.05538951542497, -1.03506269570429, -1.01473587598361, -1.94743627838372, -1.92710945866304, -1.90678263894236, -1.88645581922168, -2.81915622162179, -2.79882940190110, -2.77850258218042, -2.75817576245974,	0.285586247654995,	0.305913067375676,	0.326239887096357,	0.346566706817038,	0.775168887217581,	0.795495706938262,	0.815822526658943,	0.836149346379624,	1.26475152678017,	1.28507834650085,	1.30540516622153,	1.32573198594221},
		{17.7130738858113,	17.7020661792007,	17.6910584725901,	17.6800507659796,	18.2025328895326,	18.1915251829220,	18.1805174763114,	18.1695097697009,	18.6919918932538,	18.6809841866433,	18.6699764800327,	18.6589687734221,	19.1814508969751,	19.1704431903645,	19.1594354837540,	19.1484277771434,	18.5850307162056,	18.5740230095950,	18.5630153029845,	18.5520075963739,	19.4569875465999,	19.4459798399894,	19.4349721333788,	19.4239644267683,	20.3289443769943,	20.3179366703837,	20.3069289637732,	20.2959212571626}
	};

	const double pts_2d[2][N] =
	{
		{551.750000000000,	742.250000000000,	938.750000000000,	1126.25000000000,	565.250000000000,	745.250000000000,	938.750000000000,	1121.75000000000,	578.750000000000,	752.750000000000,	937.250000000000,	1115.75000000000,	587.750000000000,	757.250000000000,	940.250000000000,	1115.75000000000,	565.250000000000,	743.750000000000,	932.750000000000,	1111.25000000000,	578.750000000000, 748.250000000000,	926.750000000000,	1102.25000000000,	595.250000000000,	754.250000000000,	928.250000000000,	1091.75000000000},
		{583,	587.500000000000,	593.500000000000,	599.500000000000,	428.500000000000,	434.500000000000,	437.500000000000,	440.500000000000,	266.500000000000,	272.500000000000,	272.500000000000, 280.000000000000,	124.000000000000,	127.000000000000,	130.000000000000,	134.500000000000,	682,	682,	686.500000000000,	694,	767.500000000000,	769,	773.500000000000,	775,	842.500000000000,	844,	844,	850}
	};

	// Non-homogeneous coordinates
	Mat x_1 = copy_2_mat(pts_2d); // 2D-points in image plane in reference to camera coordinate system (coordinate-system 1)
	Mat X_1 = copy_2_mat(pts_3d); // 3D-world points world    in reference to camera coordinate system (coordinate-system 1)

	// Homo-geneous coordinates
	Mat x_1_ = to_homo(x_1);
	Mat X_1_ = to_homo(X_1);

	// Compute K from point-correspondances
	Proj_struct proj(calibrate(x_1_, X_1_));
	cout << "K:\n" << proj.K;;
}
//===============================================================
void part_1_method2()
{
	const double pts_3d[3][N] =
	{
		{ -1.57503155392540, -0.575298764228468,	0.424434025468468,	1.42416681516541, -1.55191826257183, -0.552185472874895,	0.447547316822041,	1.44728010651898, -1.52880497121826, -0.529072181521322,	0.470660608175614,	1.47039339787255, -1.50569167986469, -0.505958890167749,	0.493773899529187,	1.49350668922612, -1.57538506147297, -0.575652271776032,	0.424080517920904,	1.42381330761784, -1.57573856902053, -0.576005779323596,	0.423727010373340,	1.42345980007028, -1.57609207656810, -0.576359286871160,	0.423373502825777,	1.42310629252271 },
		{ -0.203996391907591, -0.183669572186910, -0.163342752466229, -0.143015932745548, -1.07571633514566, -1.05538951542497, -1.03506269570429, -1.01473587598361, -1.94743627838372, -1.92710945866304, -1.90678263894236, -1.88645581922168, -2.81915622162179, -2.79882940190110, -2.77850258218042, -2.75817576245974,	0.285586247654995,	0.305913067375676,	0.326239887096357,	0.346566706817038,	0.775168887217581,	0.795495706938262,	0.815822526658943,	0.836149346379624,	1.26475152678017,	1.28507834650085,	1.30540516622153,	1.32573198594221 },
		{ 17.7130738858113,	17.7020661792007,	17.6910584725901,	17.6800507659796,	18.2025328895326,	18.1915251829220,	18.1805174763114,	18.1695097697009,	18.6919918932538,	18.6809841866433,	18.6699764800327,	18.6589687734221,	19.1814508969751,	19.1704431903645,	19.1594354837540,	19.1484277771434,	18.5850307162056,	18.5740230095950,	18.5630153029845,	18.5520075963739,	19.4569875465999,	19.4459798399894,	19.4349721333788,	19.4239644267683,	20.3289443769943,	20.3179366703837,	20.3069289637732,	20.2959212571626 }
	};

	const double pts_2d[2][N] =
	{
		{ 551.750000000000,	742.250000000000,	938.750000000000,	1126.25000000000,	565.250000000000,	745.250000000000,	938.750000000000,	1121.75000000000,	578.750000000000,	752.750000000000,	937.250000000000,	1115.75000000000,	587.750000000000,	757.250000000000,	940.250000000000,	1115.75000000000,	565.250000000000,	743.750000000000,	932.750000000000,	1111.25000000000,	578.750000000000, 748.250000000000,	926.750000000000,	1102.25000000000,	595.250000000000,	754.250000000000,	928.250000000000,	1091.75000000000 },
		{ 583,	587.500000000000,	593.500000000000,	599.500000000000,	428.500000000000,	434.500000000000,	437.500000000000,	440.500000000000,	266.500000000000,	272.500000000000,	272.500000000000, 280.000000000000,	124.000000000000,	127.000000000000,	130.000000000000,	134.500000000000,	682,	682,	686.500000000000,	694,	767.500000000000,	769,	773.500000000000,	775,	842.500000000000,	844,	844,	850 }
	};

	// Non-homogeneous coordinates
	Mat x = copy_2_mat(pts_2d); // 2D-points in image plane in reference to camera coordinate system (coordinate-system 1)
	Mat X = copy_2_mat(pts_3d); // 3D-world points world    in reference to camera coordinate system (coordinate-system 1)

	// Number of points
	const int N = x.cols;

	// Step 1: Un-homogenize the 3D points to get 2D points - result is 28 x 2
	Mat XX = from_homo(X);

	// Step 2: Homogenize the 2D points to get 3D points by appending row of ones
	Mat x_ = to_homo(x);
	Mat XX_ = to_homo(XX);

	// Step 3: Compute the Moore-Penrose Psuedo-inverse to solve for K in closed form
	Mat XX_inv(N, 3, CV_64FC1);
	invert(XX_, XX_inv, cv::DECOMP_SVD);

	// Step 4: Solve for P with computed Moore-Penrose Psuedo-Inverse
	auto K = x_ * XX_inv;

	// Step 5: Look at the resulting K matrix
	cout << "K:\n" << K;
}
//===============================================================
int main()
{
	cout << "Part 1 - method 2:\n";
	part_1_method2();

	cout << "\n\nPart 1 - method 1:\n";
	part_1();

	cout << "\n\nPart 2:\n";
	part_2();

	return 0;
}